name: Build Begehungsbericht

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number (nur bei manuellem Start)"
        required: false
  issues:
    types: [labeled]

permissions:
  contents: read

jobs:
  build:
    # Manuell starten ODER wenn das Label "begehung" auf ein Issue gesetzt wird
    if: >-
      ${{ github.event_name == 'workflow_dispatch'
          || (github.event_name == 'issues'
              && github.event.action == 'labeled'
              && github.event.label.name == 'begehung') }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # --- Meta: Issue-Nummer bestimmen (bei issues vs. manueller Start) ---
      - name: Resolve issue number
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "num=${{ github.event.issue.number }}" >> "$GITHUB_OUTPUT"
          else
            echo "num=${{ inputs.issue_number }}" >> "$GITHUB_OUTPUT"
          fi
          echo "repo=${{ github.repository }}" >> "$GITHUB_OUTPUT"
          echo "owner=${{ github.repository_owner }}" >> "$GITHUB_OUTPUT"

      # --- Issue-Body holen & in Datei schreiben ---
      - name: Write issue body (from issues event)
        if: ${{ github.event_name == 'issues' }}
        run: |
          cat > issue_body.md <<'EOF'
          ${{ github.event.issue.body }}
          EOF

      - name: Fetch issue body (manual run)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: actions/github-script@v7
        id: fetch
        with:
          result-encoding: string
          script: |
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
            const num = parseInt("${{ steps.meta.outputs.num }}", 10);
            if (!num) {
              throw new Error("Für den manuellen Start muss 'issue_number' angegeben werden.");
            }
            const {data} = await github.rest.issues.get({owner, repo, issue_number: num});
            return data.body || "";
      - name: Write fetched body to file
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          printf "%s" "${{ steps.fetch.outputs.result }}" > issue_body.md

      # --- Python + Pandoc + LaTeX installieren ---
      - name: Install pandoc + LaTeX + Python
        run: |
          sudo apt-get update -y
          sudo apt-get install -y pandoc python3 \
            texlive-latex-recommended texlive-latex-extra \
            texlive-fonts-recommended fonts-lmodern

      # --- Markdown (report.md) & ToDo-CSV erzeugen ---
      - name: Render markdown from issue (tables, fotos)
        run: |
          python3 scripts/render_report.py

      # --- Immer erst .tex erzeugen, dann PDF versuchen ---
      - name: Build TeX and PDF
        run: |
          set -e
          mkdir -p reports

          # 1) Debug-LaTeX (.tex) immer erzeugen
          pandoc report.md \
            --from=markdown+raw_tex+pipe_tables \
            --template=docs/template.latex \
            --resource-path=".:docs" \
            -t latex \
            -o "reports/debug-${{ steps.meta.outputs.num }}.tex"

          # 2) PDF versuchen – Fehler nicht abbrechen
          set +e
          pandoc report.md \
            --from=markdown+raw_tex+pipe_tables \
            --template=docs/template.latex \
            --pdf-engine=pdflatex \
            --resource-path=".:docs" \
            -o "reports/begehung-${{ steps.meta.outputs.num }}.pdf"
          echo "Pandoc exit code: $?"
          set -e

           # --- E-Mail mit Anhang via Gmail (Python SMTP) ---
      - name: Send report via Gmail (Python SMTP, mit Anhängen)
        if: always()
        env:
          SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          HSE_TO: ${{ secrets.HSE_TO }}
          ISSUE_NUM: ${{ steps.meta.outputs.num }}
          REPO: ${{ github.repository }}
          SERVER_URL: ${{ github.server_url }}
        run: |
          set -e
          cat > send_mail.py << 'PY'
          import os, smtplib, ssl, mimetypes
          from email.message import EmailMessage

          server   = os.environ["SMTP_SERVER"]
          port     = int(os.environ["SMTP_PORT"])
          user     = os.environ["SMTP_USERNAME"]
          pwd      = os.environ["SMTP_PASSWORD"]
          sender   = os.environ["MAIL_FROM"]
          tos      = [a.strip() for a in os.environ.get("HSE_TO","").split(",") if a.strip()]
          issue    = os.environ.get("ISSUE_NUM","")
          repo     = os.environ.get("REPO","")
          base_url = os.environ.get("SERVER_URL","https://github.com")

          subject = f"Begehungsbericht #{issue}"
          body = (
              "Guten Tag,\n\n"
              f"anbei der Begehungsbericht #{issue}.\n"
              "Die Datei 'todos.csv' enthält die To-Do-Liste.\n\n"
              "Issue-Link:\n"
              f"{base_url}/{repo}/issues/{issue}\n\n"
              "Viele Grüße\n"
              "Automatischer HSE-Bericht\n"
          )

          files = [
              (f"reports/begehung-{issue}.pdf", "application/pdf"),
              ("reports/todos.csv", "text/csv"),
          ]

          msg = EmailMessage()
          msg["Subject"] = subject
          msg["From"] = sender
          msg["To"] = ", ".join(tos)
          msg.set_content(body)

          for path, fallback in files:
              if not os.path.exists(path):
                  print(f"[MAIL] Datei nicht gefunden, wird übersprungen: {path}")
                  continue
              ctype, _ = mimetypes.guess_type(path)
              maintype, subtype = (ctype or fallback).split("/", 1)
              with open(path, "rb") as f:
                  data = f.read()
              msg.add_attachment(data, maintype=maintype, subtype=subtype,
                                 filename=os.path.basename(path))
              print(f"[MAIL] Angehängt: {path}")

          ctx = ssl.create_default_context()
          with smtplib.SMTP(server, port) as smtp:
              smtp.ehlo()
              smtp.starttls(context=ctx)
              smtp.login(user, pwd)
              smtp.send_message(msg)
              print("[MAIL] Nachricht gesendet.")
          PY

          python3 send_mail.py

      # --- Artefakte hochladen (auch bei Fehlern) ---
      - name: Upload artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: begehung-${{ steps.meta.outputs.num }}
          path: |
            reports/debug-${{ steps.meta.outputs.num }}.tex
            reports/begehung-${{ steps.meta.outputs.num }}.pdf
            reports/todos.csv
          if-no-files-found: warn

