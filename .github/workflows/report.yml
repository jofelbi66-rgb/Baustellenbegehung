name: Build Begehungsbericht

on:
  issues:
    types:
      - labeled
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number"
        required: true

permissions:
  contents: read

jobs:
  build:
    # robust: nur beim manuellen Start ODER beim Label "begehung" auf Issues
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'begehung')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4


    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Issue-Nummer auflösen (manuell oder über Label-Event)
      - name: Resolve issue number
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "num=${{ inputs.issue_number }}" >> "$GITHUB_OUTPUT"
          else
            echo "num=${{ github.event.issue.number }}" >> "$GITHUB_OUTPUT"
          fi

      # Issue-Body holen (zuverlässig, auch bei manuellem Start)
      - name: Fetch issue body
        id: fetch
        uses: actions/github-script@v7
        with:
          script: |
            const n = Number("${{ steps.meta.outputs.num }}");
            const {data} = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: n,
            });
            core.setOutput('body', data.body || '');

      # Body in Datei schreiben
      - name: Write issue body to file
        run: |
          cat > issue_body.md <<'EOF'
          ${{ steps.fetch.outputs.body }}
          EOF

      - name: Install pandoc + LaTeX + Python
        run: |
          sudo apt-get update -y
          sudo apt-get install -y pandoc python3 \
            texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended fonts-lmodern

      - name: Render markdown from issue (tables)
        run: |
          python3 scripts/render_report.py

      # Immer erst .tex erzeugen, dann PDF (Fehler beim PDF brechen nicht ab)
      - name: Build TeX and PDF
        run: |
          set -e
          mkdir -p reports

          # 1) LaTeX-Quelle immer erzeugen
          pandoc report.md \
            --from=markdown+raw_tex+pipe_tables \
            --template=docs/template.latex \
            --resource-path=".:docs" \
            -t latex \
            -o "reports/debug-${{ steps.meta.outputs.num }}.tex"

          # 2) PDF versuchen – Fehler nicht abbrechen
          set +e
          pandoc report.md \
            --from=markdown+raw_tex+pipe_tables \
            --template=docs/template.latex \
            --pdf-engine=pdflatex \
            --resource-path=".:docs" \
            -o "reports/begehung-${{ steps.meta.outputs.num }}.pdf"
          echo "Pandoc exit code: $?"
          set -e
     - name: Send report via Gmail (Python SMTP, mit Anhängen)
  if: always()
  env:
    SMTP_SERVER: ${{ secrets.SMTP_SERVER }}   # smtp.gmail.com
    SMTP_PORT: ${{ secrets.SMTP_PORT }}       # 587
    SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}   # deinname@gmail.com
    SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}   # App-Passwort
    MAIL_FROM: ${{ secrets.MAIL_FROM }}           # HSE Bot <deinname@gmail.com>
    HSE_TO: ${{ secrets.HSE_TO }}                 # Empfänger, Komma-getrennt
    ISSUE_NUM: ${{ steps.meta.outputs.num }}
    REPO: ${{ github.repository }}
    SERVER_URL: ${{ github.server_url }}
  run: |
    python3 - <<'PY'
    import os, smtplib, ssl, mimetypes
    from email.message import EmailMessage

    server   = os.environ["SMTP_SERVER"]
    port     = int(os.environ["SMTP_PORT"])
    user     = os.environ["SMTP_USERNAME"]
    pwd      = os.environ["SMTP_PASSWORD"]
    sender   = os.environ["MAIL_FROM"]
    tos      = [a.strip() for a in os.environ.get("HSE_TO","").split(",") if a.strip()]
    issue    = os.environ.get("ISSUE_NUM","")
    repo     = os.environ.get("REPO","")
    base_url = os.environ.get("SERVER_URL","https://github.com")

    subject = f"Begehungsbericht #{issue}"
    body = f"""Guten Tag,

anbei der Begehungsbericht #{issue}.
Die Datei 'todos.csv' enthält die To-Do-Liste.

Issue-Link:
{base_url}/{repo}/issues/{issue}

Viele Grüße
Automatischer HSE-Bericht
"""

    # Dateien anhängen (nur wenn vorhanden)
    attachments = [
      (f"reports/begehung-{issue}.pdf", "application/pdf"),
      ("reports/todos.csv", "text/csv"),
    ]

    msg = EmailMessage()
    msg["Subject"] = subject
    msg["From"] = sender
    msg["To"] = ", ".join(tos)
    msg.set_content(body)

    for path, fallback_type in attachments:
        if not os.path.exists(path):
            print(f"[MAIL] Datei nicht gefunden, wird übersprungen: {path}")
            continue
        ctype, enc = mimetypes.guess_type(path)
        maintype, subtype = (ctype or fallback_type).split("/", 1)
        with open(path, "rb") as f:
            data = f.read()
        msg.add_attachment(data, maintype=maintype, subtype=subtype,
                           filename=os.path.basename(path))
        print(f"[MAIL] Angehängt: {path}")

    ctx = ssl.create_default_context()
    with smtplib.SMTP(server, port) as smtp:
        smtp.ehlo()
        smtp.starttls(context=ctx)
        smtp.login(user, pwd)
        smtp.send_message(msg)
        print("[MAIL] Nachricht gesendet.")
    PY

      - name: Upload artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: begehung-${{ steps.meta.outputs.num }}
          path: reports/
          if-no-files-found: warn
